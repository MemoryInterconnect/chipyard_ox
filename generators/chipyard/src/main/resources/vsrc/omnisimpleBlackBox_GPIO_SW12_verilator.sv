// Generated by CIRCT unknown git version
module omnisimpleBlackBox#(
	parameter MBUS_SEL = 1,
	parameter TL_AW = 32,
	parameter TL_DW = 32,
	parameter TL_AIW = 26,
	parameter TL_DIW = 1,
	parameter TL_DBW = 3,
	parameter TL_SZW = 2,
    parameter SRC_MAC = 48'h001232_FFFF18,
    parameter DST_MAC = 48'h001232_FFFFFA
)
(
	input				clock,
	input				reset,
 
	//GT Signals
	input	wire			gt_rxp_in,
	input	wire			gt_rxn_in,
	output 	wire			gt_txp_out,
	output 	wire			gt_txn_out,
	input   wire			gt_refclk_p,
	input   wire			gt_refclk_n,
	input   wire			mclk,

	//GPIO Inputs for Reset and Enable
	input				GPIO_SW_N, //Reset ALL
	input				GPIO_SW_S, //Enable
	input				GPIO_SW_E, //OX Core Reset
	input				GPIO_SW_W, //GCMII Reset
	input				GPIO_SW_C, //System Reset
	input				GPIO_SW12_1,

	input				tl_i_a_valid,
	input           [2:0]		tl_i_a_opcode,
	input           [2:0]		tl_i_a_param,
	input    [TL_SZW-1:0]		tl_i_a_size,
	input    [TL_AIW-1:0]		tl_i_a_source,
	input     [TL_AW-1:0]		tl_i_a_address,
	input    [TL_DBW-1:0]		tl_i_a_mask,
	input     [TL_DW-1:0]		tl_i_a_data,
	input				tl_i_a_corrupt,
	output   reg			tl_o_a_ready,
	
	output   reg          		tl_o_b_valid,
	output   reg        [2:0] 	tl_o_b_param,
	output   reg        [2:0] 	tl_o_b_opcode,
	output   reg [TL_SZW-1:0] 	tl_o_b_size,
	output   reg [TL_AIW-1:0] 	tl_o_b_source,
	output   reg  [TL_AW-1:0] 	tl_o_b_address,
	output   reg [TL_DBW-1:0] 	tl_o_b_mask,
	output   reg  [TL_DW-1:0] 	tl_o_b_data,
	output   reg             	tl_o_b_corrupt,
	input                 		tl_i_b_ready,

	input				tl_i_c_valid,
	input           [2:0]		tl_i_c_opcode,
	input           [2:0]		tl_i_c_param,
	input    [TL_SZW-1:0]		tl_i_c_size,
	input    [TL_AIW-1:0]		tl_i_c_source,
	input     [TL_AW-1:0]		tl_i_c_address,
	input     [TL_DW-1:0]		tl_i_c_data,
	input				tl_i_c_corrupt,
	output   reg			tl_o_c_ready,
	
	output   reg			tl_o_d_valid,
	output   reg        [2:0]	tl_o_d_param,
	output   reg        [2:0]	tl_o_d_opcode,
	output   reg [TL_SZW-1:0]	tl_o_d_size,
	output   reg [TL_AIW-1:0]	tl_o_d_source,
	output   reg [TL_DIW-1:0]	tl_o_d_sink,
	output   reg  [TL_DW-1:0]	tl_o_d_data,
	output   reg			tl_o_d_denied,
	output   reg			tl_o_d_corrupt,
	input				tl_i_d_ready,
	
	input        [TL_DIW-1:0]	tl_i_e_sink,
	input				tl_i_e_valid,
	output   reg			tl_o_e_ready

);
reg 	[TL_DW-1:0] 	store_a_data;
reg 	[TL_SZW-1:0] 	store_a_size;
reg 	[TL_AIW-1:0] 	store_a_source;
reg    	[2:0] 		store_a_opcode;

wire 			tl_o_a_valid_buffered;
wire 	[2:0]		tl_o_a_opcode_buffered;
wire 	[3:0]		tl_o_a_param_buffered;
wire 	[3:0]		tl_o_a_size_buffered;
wire 			tl_o_a_corrupt_buffered;
wire 	[TL_DW-1:0]	tl_o_a_data_buffered;
wire 	[TL_AIW-1:0]	tl_o_a_source_buffered;
wire 	[TL_DBW-1:0]	tl_o_a_mask_buffered;
wire 	[TL_AW-1:0]	tl_o_a_address_buffered;

// Temporary 
reg			tl_o_d_valid_user;
reg        [2:0]	tl_o_d_param_user;
reg        [2:0]	tl_o_d_opcode_user;
reg [TL_SZW-1:0]	tl_o_d_size_user;
reg [TL_AIW-1:0]	tl_o_d_source_user;
reg [TL_DIW-1:0]	tl_o_d_sink_user;
reg  [TL_DW-1:0]	tl_o_d_data_user;
reg			tl_o_d_denied_user;
reg			tl_o_d_corrupt_user;

reg			a_wait;

wire			tl_o_d_valid_ox;
wire        [2:0]	tl_o_d_param_ox;
wire        [2:0]	tl_o_d_opcode_ox;
wire [TL_SZW-1:0]	tl_o_d_size_ox;
wire [TL_AIW-1:0]	tl_o_d_source_ox;
wire [TL_DIW-1:0]	tl_o_d_sink_ox;
wire  [TL_DW-1:0]	tl_o_d_data_ox;
wire			tl_o_d_denied_ox;
wire			tl_o_d_corrupt_ox;

wire                    tx_last_data;
reg ext_reset_all_;
// Temporary 

reg [3:0] user_state;
reg [2:0] cur_state;
reg [2:0] next_state;


wire    tx_mii_clk; //PHY: TX SERDES & MII Clock
wire    reset_noc_ ;  //NOC reset concurrent with LMAC

reg [7:0] r_cnt;
parameter IDLE = 3'b000,
                        A_START = 3'b001,
                        D_START = 3'b011;

wire user_idle_st = user_state[0];
wire user_a_start_st = user_state[1];
wire user_d_start_st = user_state[2];
wire user_r_wait_st = user_state[3];

always @(posedge clock or negedge reset)
begin
        if(reset == 0)
                cur_state <= IDLE;
        else
                cur_state <= next_state;
end

always @(cur_state or tl_i_a_valid)
begin
        case(cur_state)
                IDLE : begin
                        if(tl_i_a_valid)
                                next_state = A_START;
                        else
                                next_state = IDLE;
                end
                A_START : begin
                //      next_state = A_STORE;
                        next_state = D_START;
                end
//              A_STORE : begin
//                      next_state = D_START;
//              end
                D_START : begin
                        next_state = IDLE;
                end

                default : next_state = IDLE;
        endcase
end

always @(posedge clock or negedge reset)
begin
        if(reset == 0) begin
                tl_o_a_ready <= 0;
                tl_o_d_opcode <= 3'b111;
                tl_o_d_param <= 0;
                tl_o_d_size <= 0;
                tl_o_d_source <= 0;
                tl_o_d_sink <= 0;
                tl_o_d_data <= 0;
        tl_o_d_corrupt <= 0;
                tl_o_d_valid <= 1'b0;
                store_a_data <= 0;
                store_a_size <= 0;
                store_a_source <= 0;
                store_a_opcode <= 0;
        end else begin
                case(next_state)
                        IDLE : begin
                                tl_o_a_ready <= 1;
                                tl_o_d_opcode <= 3'b111;
                                tl_o_d_param <= 0;
                                tl_o_d_size <= 0;
                                tl_o_d_source <= 0;
                                tl_o_d_sink <= 0;
                                tl_o_d_data <= 0;
                                tl_o_d_corrupt <= 0;
                                tl_o_d_valid <= 1'b0;
                        end
                        A_START : begin
                               store_a_data <= tl_i_a_opcode == 3'b000 ? tl_i_a_data : store_a_data;
                                store_a_size <= tl_i_a_size;
                                store_a_source <= tl_i_a_source;
                                store_a_opcode <= tl_i_a_opcode;
                                tl_o_a_ready <= 1;
                        end
                        D_START : begin
                                tl_o_d_valid <= 1'b1;
                                tl_o_a_ready <= 1;
                                tl_o_d_opcode <= store_a_opcode == 3'b000 ? 3'b000 : (store_a_opcode == 3'b100 ? 3'b001 : tl_o_d_opcode);
                                tl_o_d_param <= 0;
                                tl_o_d_size <= store_a_size;
                                tl_o_d_source <= store_a_source;
                                tl_o_d_sink <= 0;
                                tl_o_d_data <= store_a_opcode == 3'b100 ? store_a_data : 32'hFFBB_AACC ;
                                tl_o_d_corrupt <= 0;
                        end
                        default : begin
                                tl_o_a_ready <= 1;
                                tl_o_d_opcode <= 3'b111;
                                tl_o_d_param <= 0;
                                tl_o_d_size <= 0;
                                tl_o_d_source <= 0;
                                tl_o_d_sink <= 0;
                                tl_o_d_data <= 0;
                                tl_o_d_corrupt <= 0;
                                tl_o_d_valid <= 1'b0;
                                store_a_data <= 0;
                                store_a_size <= 0;
                                store_a_source <= 0;
                                store_a_opcode <= 0;
                        end
                endcase
        end
end

// Dual Clock FIFO 

`ifdef VERILATOR_SIM
assign tl_o_a_valid_buffered 	= tl_i_a_valid;
assign tl_o_a_opcode_buffered 	= tl_i_a_opcode;	
assign tl_o_a_param_buffered 	= tl_i_a_param;
assign tl_o_a_size_buffered 	= tl_i_a_size;
assign tl_o_a_source_buffered  	= tl_i_a_source;
assign tl_o_a_address_buffered 	= tl_i_a_address;
assign tl_o_a_mask_buffered	= tl_i_a_mask;
assign tl_o_a_data_buffered 	= tl_i_a_data;
assign tl_o_a_corrupt_buffered 	= tl_i_a_corrupt;
`endif

endmodule
